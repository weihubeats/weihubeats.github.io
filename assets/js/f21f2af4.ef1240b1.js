"use strict";(self.webpackChunkweihubeats_website=self.webpackChunkweihubeats_website||[]).push([[19],{4102:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/kafka-apis-delete-topics-01da49a3f551ae1591710a6ac2421c7a.png"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var a=n(6540);const o={},i=a.createContext(o);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:t},e.children)}},8460:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"MQ/Kafka/\u6e90\u7801\u5206\u6790/kafka\u5220\u9664topic\u6e90\u7801\u5206\u6790","title":"kafka\u5220\u9664topic\u6e90\u7801\u5206\u6790","description":"client","source":"@site/docs/MQ/Kafka/\u6e90\u7801\u5206\u6790/kafka\u5220\u9664topic\u6e90\u7801\u5206\u6790.md","sourceDirName":"MQ/Kafka/\u6e90\u7801\u5206\u6790","slug":"/MQ/Kafka/\u6e90\u7801\u5206\u6790/kafka\u5220\u9664topic\u6e90\u7801\u5206\u6790","permalink":"/docs/MQ/Kafka/\u6e90\u7801\u5206\u6790/kafka\u5220\u9664topic\u6e90\u7801\u5206\u6790","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/MQ/Kafka/\u6e90\u7801\u5206\u6790/kafka\u5220\u9664topic\u6e90\u7801\u5206\u6790.md","tags":[],"version":"current","frontMatter":{},"sidebar":"Kafka","previous":{"title":"\u804a\u804akafka client\u6027\u80fd\u8c03\u4f18\u53cakafka\u6700\u4f73\u5b9e\u8df5","permalink":"/docs/MQ/Kafka/\u6700\u4f73\u5b9e\u8df5/\u804a\u804akafka client\u6027\u80fd\u8c03\u4f18\u53cakafka\u6700\u4f73\u5b9e\u8df5"},"next":{"title":"kafka\u6d88\u606f\u53d1\u9001\u6b63\u5e38\uff0c\u6d88\u8d39\u5f02\u5e38","permalink":"/docs/MQ/Kafka/\u6e90\u7801\u5206\u6790/kafka\u6d88\u606f\u53d1\u9001\u6b63\u5e38\uff0c\u6d88\u8d39\u5f02\u5e38"}}');var o=n(4848),i=n(8453);const s={},r=void 0,d={},l=[{value:"client",id:"client",level:2},{value:"serv",id:"serv",level:2}];function c(e){const t={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"client",children:"client"}),"\n",(0,o.jsxs)(t.p,{children:["kafka\u7684\u6240\u6709",(0,o.jsx)(t.code,{children:"client"}),"\u8bf7\u6c42\u90fd\u5728",(0,o.jsx)(t.code,{children:"kafka.server.KafkaApis"}),"\u8fd9\u4e2a\u7c7b\u8fdb\u884c\u5206\u53d1"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"kafka.server.KafkaApis"})," \u8fd9\u4e2a\u7c7b\u7528\u7684\u4e0d\u662fjava\u8bed\u8a00\u5b9e\u73b0\u7684\uff0c\u4e3b\u8981\u7528\u7684\u662f",(0,o.jsx)(t.code,{children:"scala"})]}),"\n",(0,o.jsxs)(t.p,{children:["\u8bf7\u6c42\u7c7b\u578b\u57fa\u4e8e",(0,o.jsx)(t.code,{children:"scala"}),"\u5f3a\u5927\u7684\u6a21\u5f0f\u5339\u914d\u8bed\u6cd5\u8fdb\u884c\u5206\u53d1\u7684"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"alt text",src:n(4102).A+"",width:"1551",height:"680"})}),"\n",(0,o.jsx)(t.h2,{id:"serv",children:"serv"}),"\n",(0,o.jsxs)(t.p,{children:["server\u7684\u5904\u7406\u4ee3\u7801\u4e5f\u662f\u7c7b\u4f3c\uff0c\u8bf7\u6c42\u5206\u53d1\u4e3b\u8981\u662f\u5728",(0,o.jsx)(t.code,{children:"ControllerApis"})]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"alt text",src:n(8769).A+"",width:"1502",height:"780"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"  private def handleDeleteTopics(request: RequestChannel.Request): CompletableFuture[Unit] = {\n    val deleteTopicsRequest = request.body[DeleteTopicsRequest]\n    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, strictSinceVersion = 5)\n    val context = new ControllerRequestContext(request.context.header.data, request.context.principal,\n      requestTimeoutMsToDeadlineNs(time, deleteTopicsRequest.data.timeoutMs),\n      controllerMutationQuotaRecorderFor(controllerMutationQuota))\n    val future = deleteTopics(context,\n      deleteTopicsRequest.data,\n      request.context.apiVersion,\n      authHelper.authorize(request.context, DELETE, CLUSTER, CLUSTER_NAME, logIfDenied = false),\n      names => authHelper.filterByAuthorized(request.context, DESCRIBE, TOPIC, names)(n => n),\n      names => authHelper.filterByAuthorized(request.context, DELETE, TOPIC, names)(n => n))\n    future.handle[Unit] { (results, exception) =>\n      val response = if (exception != null) {\n        deleteTopicsRequest.getErrorResponse(exception)\n      } else {\n        val responseData = new DeleteTopicsResponseData()\n          .setResponses(new DeletableTopicResultCollection(results.iterator))\n        new DeleteTopicsResponse(responseData)\n      }\n      requestHelper.sendResponseMaybeThrottleWithControllerQuota(controllerMutationQuota, request, response)\n    }\n  }\n\n"})}),"\n",(0,o.jsxs)(t.p,{children:["\u5b9e\u9645\u7684\u5220\u9664",(0,o.jsx)(t.code,{children:"topic"}),"\u903b\u8f91\u90fd\u5c01\u88c5\u5728",(0,o.jsx)(t.code,{children:"deleteTopics"}),"\u4e2d\uff0c\u8fd9\u91cc\u53ea\u662f\u505a\u4e86\u4e00\u4e9b\u65b9\u6cd5\u8c03\u7528\u7684\u53c2\u6570\u7ec4\u88c5\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7ee7\u7eed\u770b\u770b",(0,o.jsx)(t.code,{children:"deleteTopics"}),"\u65b9\u6cd5"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'  def deleteTopics(\n    context: ControllerRequestContext,\n    request: DeleteTopicsRequestData,\n    apiVersion: Int,\n    hasClusterAuth: Boolean,\n    getDescribableTopics: Iterable[String] => Set[String],\n    getDeletableTopics: Iterable[String] => Set[String]\n  ): CompletableFuture[util.List[DeletableTopicResult]] = {\n    // Check if topic deletion is enabled at all.\n    if (!config.deleteTopicEnable) {\n      if (apiVersion < 3) {\n        return CompletableFuture.failedFuture(new InvalidRequestException("This version does not support topic deletion."))\n      } else {\n        return CompletableFuture.failedFuture(new TopicDeletionDisabledException())\n      }\n    }\n    // The first step is to load up the names and IDs that have been provided by the\n    // request.  This is a bit messy because we support multiple ways of referring to\n    // topics (both by name and by id) and because we need to check for duplicates or\n    // other invalid inputs.\n    val responses = new util.ArrayList[DeletableTopicResult]\n    def appendResponse(name: String, id: Uuid, error: ApiError): Unit = {\n      responses.add(new DeletableTopicResult().\n        setName(name).\n        setTopicId(id).\n        setErrorCode(error.error.code).\n        setErrorMessage(error.message))\n    }\n    val providedNames = new util.HashSet[String]\n    val duplicateProvidedNames = new util.HashSet[String]\n    val providedIds = new util.HashSet[Uuid]\n    val duplicateProvidedIds = new util.HashSet[Uuid]\n    def addProvidedName(name: String): Unit = {\n      if (duplicateProvidedNames.contains(name) || !providedNames.add(name)) {\n        duplicateProvidedNames.add(name)\n        providedNames.remove(name)\n      }\n    }\n    request.topicNames.forEach(addProvidedName)\n    request.topics.forEach {\n      topic => if (topic.name == null) {\n        if (topic.topicId.equals(ZERO_UUID)) {\n          appendResponse(null, ZERO_UUID, new ApiError(INVALID_REQUEST,\n            "Neither topic name nor id were specified."))\n        } else if (duplicateProvidedIds.contains(topic.topicId) || !providedIds.add(topic.topicId)) {\n          duplicateProvidedIds.add(topic.topicId)\n          providedIds.remove(topic.topicId)\n        }\n      } else {\n        if (topic.topicId.equals(ZERO_UUID)) {\n          addProvidedName(topic.name)\n        } else {\n          appendResponse(topic.name, topic.topicId, new ApiError(INVALID_REQUEST,\n            "You may not specify both topic name and topic id."))\n        }\n      }\n    }\n    // Create error responses for duplicates.\n    duplicateProvidedNames.forEach(name => appendResponse(name, ZERO_UUID,\n      new ApiError(INVALID_REQUEST, "Duplicate topic name.")))\n    duplicateProvidedIds.forEach(id => appendResponse(null, id,\n      new ApiError(INVALID_REQUEST, "Duplicate topic id.")))\n    // At this point we have all the valid names and IDs that have been provided.\n    // However, the Authorizer needs topic names as inputs, not topic IDs.  So\n    // we need to resolve all IDs to names.\n    val toAuthenticate = new util.HashSet[String]\n    toAuthenticate.addAll(providedNames)\n    val idToName = new util.HashMap[Uuid, String]\n    controller.findTopicNames(context, providedIds).thenCompose { topicNames =>\n      topicNames.forEach { (id, nameOrError) =>\n        if (nameOrError.isError) {\n          appendResponse(null, id, nameOrError.error())\n        } else {\n          toAuthenticate.add(nameOrError.result())\n          idToName.put(id, nameOrError.result())\n        }\n      }\n      // Get the list of deletable topics (those we can delete) and the list of describable\n      // topics.\n      val topicsToAuthenticate = toAuthenticate.asScala\n      val (describable, deletable) = if (hasClusterAuth) {\n        (topicsToAuthenticate.toSet, topicsToAuthenticate.toSet)\n      } else {\n        (getDescribableTopics(topicsToAuthenticate), getDeletableTopics(topicsToAuthenticate))\n      }\n      // For each topic that was provided by ID, check if authentication failed.\n      // If so, remove it from the idToName map and create an error response for it.\n      val iterator = idToName.entrySet().iterator()\n      while (iterator.hasNext) {\n        val entry = iterator.next()\n        val id = entry.getKey\n        val name = entry.getValue\n        if (!deletable.contains(name)) {\n          if (describable.contains(name)) {\n            appendResponse(name, id, new ApiError(TOPIC_AUTHORIZATION_FAILED))\n          } else {\n            appendResponse(null, id, new ApiError(TOPIC_AUTHORIZATION_FAILED))\n          }\n          iterator.remove()\n        }\n      }\n      // For each topic that was provided by name, check if authentication failed.\n      // If so, create an error response for it. Otherwise, add it to the idToName map.\n      controller.findTopicIds(context, providedNames).thenCompose { topicIds =>\n        topicIds.forEach { (name, idOrError) =>\n          if (!describable.contains(name)) {\n            appendResponse(name, ZERO_UUID, new ApiError(TOPIC_AUTHORIZATION_FAILED))\n          } else if (idOrError.isError) {\n            appendResponse(name, ZERO_UUID, idOrError.error)\n          } else if (deletable.contains(name)) {\n            val id = idOrError.result()\n            if (duplicateProvidedIds.contains(id) || idToName.put(id, name) != null) {\n              // This is kind of a weird case: what if we supply topic ID X and also a name\n              // that maps to ID X?  In that case, _if authorization succeeds_, we end up\n              // here.  If authorization doesn\'t succeed, we refrain from commenting on the\n              // situation since it would reveal topic ID mappings.\n              duplicateProvidedIds.add(id)\n              idToName.remove(id)\n              appendResponse(name, id, new ApiError(INVALID_REQUEST,\n                "The provided topic name maps to an ID that was already supplied."))\n            }\n          } else {\n            appendResponse(name, ZERO_UUID, new ApiError(TOPIC_AUTHORIZATION_FAILED))\n          }\n        }\n        // Finally, the idToName map contains all the topics that we are authorized to delete.\n        // Perform the deletion and create responses for each one.\n        controller.deleteTopics(context, idToName.keySet).thenApply { idToError =>\n          idToError.forEach { (id, error) =>\n            appendResponse(idToName.get(id), id, error)\n          }\n          // Shuffle the responses so that users can not use patterns in their positions to\n          // distinguish between absent topics and topics we are not permitted to see.\n          Collections.shuffle(responses)\n          responses\n        }\n      }\n    }\n  }\n'})}),"\n",(0,o.jsx)(t.p,{children:"\u6838\u5fc3\u5220\u9664\u903b\u8f91"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"controller.deleteTopics\n"})})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8769:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/kafka-controller-apis-delete-topics-64fa922b6d2ffb333ef84f368d4aa040.png"}}]);